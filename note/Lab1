2022-11-20 开始lab1
1 用户程序是通过mkfs/mkfs直接写进fs.img里的，运行是通过exec从文件系统里读到内存里。
  因此想调试，应该就只能等pc跳过去之后，在gdb里手动看汇编
2 测试sleep代码  make GRADEFLAGS=sleep grade   ---> ./grade-lab-util pingpong
3 用户程序 直接在本机上调试就行  不需要在qemu+xv6上调试(调试不了)
4 读取管道时 如果没有读取到数据会自动阻塞住，
   如果父进程没死 子进程使用打印输出时是很干净的输出如下
   1
   2
   3
   4
   5
   ...
   如果父进程在子进程打印的过程中挂掉了 则打印会另起一行 注意会有个$ 前缀
   1
   2
   3
  $4
   5
   6
   ...
5 在native xv6 的环境中 父进程挂掉了 不做处理的话 子进程不会挂掉，还是正常执行。
6 2022-12-03 
  在xv6的代码中 
  如果子进程先 read 卡主了， 父进程close掉挂到后  子进程不能从read中退出来
  而在native的环境中 这种情况是 子进程会直接从read中退出   
  就是说 xv6 的实验代码中 primes 实现时  不能在子进程中使用
  while(read(pipe, buff, sizeof(int)) != 0) 使用是否读取到数据来标识子进程的管道中没有数据了
  因为read不能退出来，
  所以只能用讲义上说的 管道中读取到0 来标识 父进程不再会向管道中写入数据了 从而子进程退出读取
