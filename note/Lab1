2022-11-20 开始lab1
1 用户程序是通过mkfs/mkfs直接写进fs.img里的，运行是通过exec从文件系统里读到内存里。
  因此想调试，应该就只能等pc跳过去之后，在gdb里手动看汇编
2 测试sleep代码  make GRADEFLAGS=sleep grade   ---> ./grade-lab-util pingpong
3 用户程序 直接在本机上调试就行  不需要在qemu+xv6上调试(调试不了)
4 读取管道时 如果没有读取到数据会自动阻塞住，
   如果父进程没死 子进程使用打印输出时是很干净的输出如下
   1
   2
   3
   4
   5
   ...
   如果父进程在子进程打印的过程中挂掉了 则打印会另起一行 注意会有个$ 前缀
   1
   2
   3
  $4
   5
   6
   ...
5 在native xv6 的环境中 父进程挂掉了 不做处理的话 子进程不会挂掉，还是正常执行。
6 2022-12-03 
  在xv6的代码中 
  如果子进程先 read 卡主了， 父进程close掉挂到后  子进程不能从read中退出来
  而在native的环境中 这种情况是 子进程会直接从read中退出   
  就是说 xv6 的实验代码中 primes 实现时  不能在子进程中使用
  while(read(pipe, buff, sizeof(int)) != 0) 使用是否读取到数据来标识子进程的管道中没有数据了
  因为read不能退出来，
  所以只能用讲义上说的 管道中读取到0 来标识 父进程不再会向管道中写入数据了 从而子进程退出读取
7 launch.json中配置 调试的程序位 /user/_ls 来调试用户程序  /kernel/kernel 调试内核程序
   之所以能调试用户程序 我猜测是因为ls是 裸机程序  这里待定。
8 ls 命令 ls . 和 ls .. 是一样的结果  ls到底是 ls的那个目录？？？
9 
  多命令的间隔符号： 
  & 同时执行； 
  && 前面成功才执行后面； 
  |: 前面的结果传给后面；  (管道命令 将标准输出转换为标砖输入)
  || 前面的成功后面不执行，前面失败后面才执行 

10 peek 参数二位指针 在函数内部修改了字符串指针
11 xargs 实现思路可能有问题  我以为是要从像管道符 | 一样在sh.c 里面来处理 xargs 命令呢
12 sh.c 解析命令行参数的代码 有必要好好研究下 TODO
